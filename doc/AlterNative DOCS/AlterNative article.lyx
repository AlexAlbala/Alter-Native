#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
AlterNative: An executable to executable Cross-platform system for translating
 high-level to native applications
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Nowadays all the service sectors like industrial, energy, healthcare, security
 among others are including new technological devices connected in the network.
 The number of interconnected devices is increasing exponentially in the
 last years.
 Therefore there are appearing huge variety of devices, with different operating
 systems and different programming languages.
 In other words the future situation can be described as an heterogeneous
 distributed system.
 The future of the devices tends to converge in a multiplatform environment
 composed by different devices and elements but with similar capabilites
 and possibilities, not only smartphones, smart TVs or tablets but also
 all kind of elements.
 In this work we present the AlterNative software as a cross-platform code
 translation tool focused on the performance of applications maintaining
 the maximum number of functionalities.
 AlterNative tries to solve the problem of multiplatform software avoiding
 the use of elements which can be perjudicial to the performance like virtual
 machines and aims to increase the efficiency of the code by using native
 languages.
\end_layout

\begin_layout Section
State Of The Art
\end_layout

\begin_layout Standard
The rising market of Internet of Things devices promotes the development
 of software and tools for maintaining the interoperability between devices
 it is necessary to compile applications written in the specific language
 that accepts the processor.
 One option is to deploy Virtual Machines in all the devices benefiting
 of the portability of the code, but the performance it is not ideal.
 The State of the Art can be dividide in three main groups: Code translators,
 Decompilers and Research projects.
\end_layout

\begin_layout Subsection
Code Translators
\end_layout

\begin_layout Standard
The translator is a tool for converting the code compiled for one system
 to the same application but compiled for other system.
 The translation can be done in the source code level (change text strings)
 or in other levels like byte code level (change instructions).
 The translation provides the user with a tool which for developing the
 application in a comfortable language (high-level language) benefiting
 of all the high-level features and gaining time in the programming stage.
 When the code is finished, the translator is able to port this application
 developed in a high-level language to a low-level language programmed applicati
on, benefitting of the speed and performance of these languages.
 In this section the more relevant considered translators are explained.
 
\end_layout

\begin_layout Subsection
Decompilers
\end_layout

\begin_layout Standard
For this work it is important to study different tools for extract code
 from applications or assemblies.
 This feature allows extracting information of the code and program structure
 from a file which is previously compiled.
 In this section will be studied different decompilers and assembly browsers.
 All of them have approximately the same features, the only difference is
 the languages supported (input and output languages).
 
\end_layout

\begin_layout Subsection
Research projects
\end_layout

\begin_layout Subsubsection
Particle code
\end_layout

\begin_layout Standard
The Particle Platform 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"

\end_inset

 is an open and extensible cross-platform end-to-end solution that enables
 developers to create native applications for smartphone platforms as well
 as HTML5 web applications.
 It allows developers to code in modern object-oriented languages like Java
 and ActionScript3, while working in the popular Eclipse IDE with a robust
 WYSIWYG front-end to manage User Interface design on various devices.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
CAMBIAR
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/ParticleCode.png
	lyxscale 50
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Particle Code engine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Rhodes
\end_layout

\begin_layout Standard
Rhodes 
\begin_inset CommandInset citation
LatexCommand cite
key "key-2"

\end_inset

 is an open source Ruby-based framework to rapidly build native apps for
 all major smartphone operating systems (iPhone, Android, RIM, Windows Mobile
 and Windows Phone 7).
 These are true native device applications (NOT mobile web apps) which work
 with synchronized local data and take advantage of device capabilities
 such as GPS, PIM contacts and calendar, camera, native mapping, push, barcode,
 signature capture, Bluetooth and Near Field Communications (NFC).
\end_layout

\begin_layout Standard
Rhodes is the ONLY framework with: support for Model View Controller (other
 frameworks force you to put all business logic into the view as JavaScript),
 synchronized data (the price of entry for enterprise apps), support for
 ALL devices (Android and iPhone is not "crossplatform"), a hosted build
 service (RhoHub â€“ which changes the game for mobile app development entirely)
 and true industrial device capabilities such as NFC.
 Rhodes has many other major advantages over every other framework and underlyin
g SDK, which can be summarized as modern development goodness for mobile
 apps.
\begin_inset Note Note
status open

\begin_layout Plain Layout
MODIFICAR
\end_layout

\end_inset


\end_layout

\begin_layout Section
Concept
\end_layout

\begin_layout Standard
The concept of AlterNative is to maximize the idea of Internet of Things
 by providing a tool for easy port applications from hmirigh-level languages
 (such as .NET) to native languages (such as C++).
 Most of the actual systems are C++ compatible, thus if the application
 is ported to this language, it can be executed in several platforms (i.e.
 smartphones, tablets, embedded systems, computers with different operating
 systems).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/Concpet.PNG
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AlterNative concept
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The philosophy of AlterNative is to provide the user with a system for taking
 the advantage of fast developing of high-level languages and also take
 the advantage of performance of low-level languages, and also exploit the
 possibility of run the native code in several systems, in other words,
 this philosophy is similar to the WORA (Write Once, Run Anywhere) slogan
 created by Sun Microsystems to illustrate the cross-platform benets of
 the Java Virtual Machine.
 The difference is focused on the final performance since AlterNative outputs
 in native language and does not depend on any virtual machine.
\end_layout

\begin_layout Section
Process
\end_layout

\begin_layout Standard
The process of the AlterNative software is divided in three parts: Decompilation
, translation and compilation.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/Process.PNG
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AlterNative process
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
First of all the assembly received is passed through a decompiler in order
 to extract the source code.
 In this case the code extracted is C#.
 The code is not extracted in text format, but in an AST (Abstract Syntax
 Tree) that is an abstract representation with nodes and hierarchies of
 the code.
 This representation is organized in a tree from the top-level (Assembly)
 until de low-level (instructions, types and constants).
 The step of translation consists on apply different conversions to the
 AST in order to obtain a second AST representing the source code but in
 other language (in this case C++).
 The final step consists on compile the C++ code into a new assembly.
 This final assembly maintains the same funcionalities of the first assembly
 but takes benet of the native code performance.
 The effort of this software is not focused on the code translation, but
 it is focused in maintaining all the features and functionalities of the
 original code.
 The problem is that these features and functionalities often are directly
 related to the language, for instance a garbage collector, specic expressions
 or even language syntax.
 AlterNative is able to provide most of the features of the original code
 to the final code using external open-source libraries and propietary libraries
 in order to be fully compatible with high-level languages.
\end_layout

\begin_layout Section
Use case
\end_layout

\begin_layout Standard
In general the major advantage of this platform can be obtained when an
 application or library is very complex in a computational way.
 The more complex is the target, the more the benefit can be obtained.
\end_layout

\begin_layout Standard
Suppose the following scenario:
\end_layout

\begin_layout Standard
You have an application for Android written in Java.
 The Android system is composed by a Java application running over a DalvikVM
 (Java Virtual Machine) which is running over a unix distribution.
 This application takes several images from the camera and processes each
 frame in order to change from YUV format (Android standard) to RGB format.
 After trying your application in Java environment you obtain a framerate
 of 7 frames per second.
 After this test you want to upgrade your application improving the performance.
 AlterNative platform allows you to take the Java code layer in charge of
 processing the image and convert it to C++ code (and also provides you
 the code with JNI naming ready to use in Android or Java environments)
 which allows you to run code below the DalvikVM.
 After that you repeat the test but with the processing layer running in
 C++ and you obtain 14 frames per second (two times faster than the first
 one).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/JavaProc.png
	lyxscale 40
	width 25text%
	height 17text%

\end_inset


\begin_inset Graphics
	filename Figures/nativeProc.png
	lyxscale 40
	width 25text%
	height 17text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Java vs C++ performance
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
For the evaluation of the system a CPU stress performance test will be executed.
 The test selected is the fannkuch-redux benchmark 
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"

\end_inset

.
 The C# code used is listed below.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/fannkuch-redux.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fannkuch-redux test
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have compared three languages with three compilation targets.
 The languages are C# (original), C++ original (manually translated) and
 C++ alternative (obtained automatically).
 The three compilation targets are Windows 32 bits, Linux and Android) all
 of them with Release optimizations
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/CompVsLang.emf
	lyxscale 30
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Time in function of the target platform
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
Most of the cross-platform tools in the community are focused only on fast
 development for different devices (for instance games for smartphones).
 AlterNative a part of maintaining the objective of facilitate the easy
 and fast development, also is focused on the final performance of the applicati
on.
 Multiplatform systems based on virtual machines, or in HTML + CSS frameworks
 are useful for visual applications which do not require a high computational
 power, the main advantage of AlterNative software is that it is able to
 run code with native performance while the user is programming its code
 without taking into account the final application performance.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

http://www.particlecode.com/
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

http://www.motorola.com/Business/US-EN/RhoMobile+Suite/Rhodes
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

(http://shootout.alioth.debian.org/u32/performance.php?test=fannkuchredux)
\end_layout

\end_body
\end_document
