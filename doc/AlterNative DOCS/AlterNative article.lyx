#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\tiny},language={[GNU]C++}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
AlterNative: An executable to executable Cross-platform system for translating
 high-level to native applications
\end_layout

\begin_layout Author
A.
 Albalá, J.
 López.
 
\end_layout

\begin_layout Abstract
Cross-platform applications are increasing their market due to the growing
 number of heterogeneous devices in the market.
 Developers are required to design and implement the software application
 in all the different targets that the product will be available.
 In this paper it is presented AlterNative, a cross-platform that tries
 to solve the problem of the fast development in multi-platform (cross-platform)
 applications maintaining a good performance.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Nowadays all the service sectors like industrial, energy, healthcare, security
 among others are including new technological devices connected in the network.
 The number of interconnected devices is increasing exponentially in the
 last years.
 Therefore there are appearing huge variety of devices, with different operating
 systems and different programming languages.
 In other words the future situation can be described as an heterogeneous
 distributed system.
 The future of the devices tends to converge in a multiplatform environment
 composed by different devices and elements but with similar capabilites
 and possibilities, not only smartphones, smart TVs or tablets but also
 all kind of elements.
 In this work we present the AlterNative software as a cross-platform code
 translation tool focused on the performance of applications maintaining
 the maximum number of functionalities.
 AlterNative tries to solve the problem of multiplatform software avoiding
 the use of elements which can be perjudicial to the performance like virtual
 machines and aims to increase the efficiency of the code by using native
 languages.
\end_layout

\begin_layout Section
State Of The Art
\end_layout

\begin_layout Standard
The rising market of Internet of Things devices promotes the development
 of software and tools for maintaining the interoperability between devices
 it is necessary to compile applications written in the specific language
 that accepts the processor.
 One option is to deploy Virtual Machines in all the devices benefiting
 of the portability of the code, but the performance it is not ideal.
 The State of the Art can be classified in multi-platform tools, decompilers
 and code translators.
\end_layout

\begin_layout Subsection
Multi-platform and cross-platform mobile tools
\end_layout

\begin_layout Standard
There are different multi-platform tools that aim to make easy the development
 of mobile applications targeting the different operating systems of the
 market.
 Fore more information of the most popular cross-platform tools see 
\begin_inset CommandInset citation
LatexCommand cite
key "key-13"

\end_inset

.
 A brief summary of the framework is provided.
\end_layout

\begin_layout Subsubsection
PhoneGap 
\begin_inset CommandInset citation
LatexCommand cite
key "key-19"

\end_inset


\end_layout

\begin_layout Standard
PhoneGap is an open-source mobile development tool developed by Adobe System
 Inc.
 under Apache 2.0 license.
 PhoneGap allows developers and companies to build free, commercial and
 open-source applications, and give them also the possibility to use any
 licenses combination.
 The development environment is cross-platform and permits the creation
 of applications for Android, Bada, BlackBerry, iOS, Symbian, webOS and
 Windows Phone OS’s.
\end_layout

\begin_layout Standard
This framework is composed by a java library file and html files for the
 application views.
 PhoneGap provides an API for control the core of the mobile (sensors, camera,
 media ...) and uses standard JavaScript, HTML5 and CSS3 for bringing the views
 to the user.
 The use of all these standards allow PhoneGap to provide to the developers
 with a framework compatible with most of the operating systems in the mobile
 market.
 PhoneGap is compatible with: iOS, Android, Blacberry OS, WebOS, Windows
 Phone, Symbian and Bada.
\end_layout

\begin_layout Subsubsection
Rhodes 
\begin_inset CommandInset citation
LatexCommand cite
key "key-24"

\end_inset


\end_layout

\begin_layout Standard
Rhodes 3.3.3 is a cross-platform mobile application tool developed by Motorola
 Solutions Inc.
 under Massachusetts Institute of Technology (MIT).
 It is developed to rapidly build native applications for all major mobile
 OS’s (iOS, Android, BlackBerry, Windows Mobile/Phone and Symbian).
 The main goal of Rhodes is to provide a high level of productivity and
 portability in programming.
 It is an open source Ruby-based mobile development environment.
 Thanks to this environment, developers can create and maintain enterprise
 applications and data based on single source code across different mobile
 OS’s.
 RhoMobile suite provides an IDE called RhoStudio which is an innovative
 solution dedicated to users that want to develop applications through a
 hosted IDE.
 This solution can be used across Linux, Mac, and Microsoft Windows OS’s.
 Alternatively, RhoMobile offers the possibility to write applications with
 any other editor or IDE which supports HTML, HTML5, CSS, JavaScript and
 Ruby.
 Rhodes aims to bring agility 
\begin_inset CommandInset citation
LatexCommand cite
key "key-20"

\end_inset

 to the mobile development world.
\end_layout

\begin_layout Subsubsection
DragonRad 
\begin_inset CommandInset citation
LatexCommand cite
key "key-21"

\end_inset


\end_layout

\begin_layout Standard
DragonRad 5.0 is a cross-platform mobile application development platform
 by Seregon Solutions Inc.
 and distributed Fig.
 3.
 Complete schema of PhoneGap architecture and interfacing among components
 [5].
 under a commercial license.
 It allows developers to design, manage and deploy mobile applications once
 and use it across iOS, Android, BlackBerry and Windows Mobile [3].
 The tool focuses on database driven mobile enterprise applications with
 easy and wide range of databases support.
 It provides the D&D environment which help developers to save programming
 time and to create logics.
 DragonRad provides their own built IDE, that can be configured for different
 simulators like iOS, Android, BlackBerry, Windows Mobile etc.
\end_layout

\begin_layout Subsubsection
MoSync 
\begin_inset CommandInset citation
LatexCommand cite
key "key-22"

\end_inset


\end_layout

\begin_layout Standard
MoSync 4.0 is an open source solution developed by a Swedish company targeted
 to mobile market.
 MoSync has fully fledged SDK which helps developers to build and package
 all type of mobile applications, such as simple, advanced and complex applicati
on that share the same code base.
 MoSync SDK is proving to be very powerful tool with many components tightly
 coupled together like Libraries, Runtimes, Device Profile Database and
 Compilers, and so on.
 It provides the full fledge Eclipse-based IDE and the use of standard C/C++.
 It also added the support with web-based language like HTML, HTML5, CSS
 and JavaScript.
 It provides well documented API’s both in C/C++ and web-based.
 The idea involved to support multiple mobile OS’s is different from other
 tools and also in very isolated way from other mobile operating code.
 Applications in MoSync are built to target a device profile by using GNU
 Compiler Collection (GCC) and pipetool.
 After writing the application, pipe-tool is used to compile the resources
 present in the application.
 Then GCC backend is called and path to target device profile passed to
 it.
 GCC uses it to produce MoSync intermediate language, which then fed in
 to pipe-tool.
 Then, pipe-tool behaves as the bridge between MoSync applications to target
 device profile.
 The profile database helps the application in ensuring that it has adapted
 correctly to the device.
 Runtimes are libraries which are bound to provide support related to all
 like regarding graphics, audio, communications, input, uniform interface
 to low level system API’s and other device features.
\end_layout

\begin_layout Subsection
Graphical multi-platform tools
\end_layout

\begin_layout Standard
Graphical libraries and features usually are very specific in each language
 (and operative system).
 There are several projects that try to solve this problem by enabling the
 developer design a cross-platform graphical interface.
\end_layout

\begin_layout Subsubsection
OpenGL
\end_layout

\begin_layout Standard
OpenGL (Open Graphics Library) is a cross-language, multi-platform application
 programming interface, developed by Silicon Graphics Inc., for rendering
 2D and 3D vector graphics.
 The API is typically used to interact with a Graphics Processing Unit (GPU)
 in order to achieve the best performance for rendering.
\end_layout

\begin_layout Standard
OpenGL also has OpenGL ES (OpenGL for Embedded Systems) optimized for mobile
 development.
\end_layout

\begin_layout Subsubsection
Qt
\end_layout

\begin_layout Standard
Qt Project is a cross-platform application and UI framework for decelopers
 using C++ or QML, a CSS & JavaScript like language.
 Qt Creator is the supporting Qt IDE.
\end_layout

\begin_layout Subsection
Decompilers
\end_layout

\begin_layout Standard
For this work it is important to study different tools for extract code
 from applications or assemblies.
 This feature allows extracting information of the code and program structure
 from a file which is previously compiled.
 In this section will be studied different decompilers and assembly browsers.
 All of them have approximately the same features, the only difference is
 the languages supported (input and output languages).
 
\end_layout

\begin_layout Standard
ILSpy 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"

\end_inset

 is a .NET assembly browser and decompiler.
 It is open-source and its development started after the announcement that
 the free version of NET Reflector would cease to exist by end of February
 2011.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/ILSpy.PNG
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ILSpy decompiler
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
ILSpy loads the assembly with the Mono.CECIL library (explained after in
 this chapter).
 This library inspects programs and libraries in CIL format.
 With the CECIL library the ILSPy extracts all the types definitions, methods,
 fields etc.
 Through an AST Builder, the program generates an Abstract Syntax Tree represent
ing the source code in an abstract way.
 
\end_layout

\begin_layout Standard
An abstract syntax tree (AST) is a tree representation of the abstract syntactic
 structure of source code written in a programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "key-12,key-5"

\end_inset

.
 Each node of the tree denotes a construct occurring in the source code.
 The syntax is 'abstract' in not representing every detail appearing in
 the real syntax.
 The final stage is to convert this Abstract Syntax Tree in text (source
 code).
 This program defines different templates, each one for each language.
 The supported output languages are: IL, C# and VB.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/ILSpyp.PNG
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ILSPy process
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are several decompilers in the community that aim to the same objective
 as ILSpy does, the difference between them are the languages that they
 accept or the languages that they provide at the output.
\end_layout

\begin_layout Standard
In this work the ILSpy decompiler is used as the basis for the decompilation
 process of the assembly.
 ILSpy is in charge of get the assembly, extract the AST tree and get the
 source code from this tree.
 This process will allow this work to get an abstract representation of
 the source code.
\end_layout

\begin_layout Subsection
Code Translators
\end_layout

\begin_layout Standard
The translator is a tool for converting the code compiled for one system
 to the same application but compiled for other system.
 The translation can be done in the source code level (change text strings)
 or in other levels like byte code level (change instructions).
 The translation provides the user with a tool which for developing the
 application in a comfortable language (high-level language) benefiting
 of all the high-level features and gaining time in the programming stage.
 When the code is finished, the translator is able to port this application
 developed in a high-level language to a low-level language programmed applicati
on, benefitting of the speed and performance of these languages.
 In this section the more relevant considered translators are explained.
\end_layout

\begin_layout Subsubsection
Particle code: end to end solution
\end_layout

\begin_layout Standard
The Particle Platform 
\begin_inset CommandInset citation
LatexCommand cite
key "key-14"

\end_inset

 is an open and extensible cross-platform end-to-end solution that enables
 developers to create native applications for smartphone platforms as well
 as HTML5 web applications.
 It allows developers to code in modern object-oriented languages like Java
 and ActionScript3, while working in the popular Eclipse IDE with a robust
 WYSIWYG front-end to manage User Interface design on various devices.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/ParticleCode.png
	lyxscale 50
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Particle Code engine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
AlterNative contributions
\end_layout

\begin_layout Standard
In this chapter have been studied all the existing solutions targeting the
 same concept of AlterNative aims to.
 The most advanced research line is the Decompilers line, but these decompilers
 always target high-level languages and often do not output a legible code
 with a high-performance.
 AlterNative will take benefit of all the work done in this line and will
 use ILSpy decompiler for obtain the source code of an assemblied file in
 order to translate it to a low level language.
\end_layout

\begin_layout Standard
Nowadays, as the mobile and embedded market is increasing, the multiplatform
 tools for these markets are growing.
 However, these tools are focused on unify the application graphical user
 interface by means of standard web languages (i.e.
 HTML and CSS).
 The frameworks that aim to unify also the logical part are based on non-native
 code libraries.
 The performance is good enough but the can not target to other devices
 rather than modern mobile devices.
\end_layout

\begin_layout Standard
Concluding the AlterNative objective, this project aims to unify the best
 of all the multi-platform worlds for create and innovative tool able to
 translate specific high-level apps to multi-platform native applications
 reducing the development time and increasing the portability and performance
 of the application.
 A key point that makes AlterNative become a novel project is the possibility
 of not only run in graphics powered operating systems but also terminal
 applications with compatibility even in low power embedded systems.
\end_layout

\begin_layout Section
Concept
\end_layout

\begin_layout Subsection
Description
\end_layout

\begin_layout Standard
The concept of AlterNative is to maximize the idea of Internet of Things
 by providing a tool for easy port applications from high-level languages
 (such as .NET) to native languages (such as C++).
 Most of the actual systems are C++ compatible, thus if the application
 is ported to this language, it can be executed in several platforms (i.e.
 smartphones, tablets, embedded systems, computers with different operating
 systems).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/Concpet.PNG
	width 60col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AlterNative concept
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The philosophy of AlterNative is to provide the user with a system for taking
 the advantage of fast developing of high-level languages and also take
 the advantage of performance of low-level languages, and also exploit the
 possibility of run the native code in several systems, in other words,
 this philosophy is similar to the WORA (Write Once, Run Anywhere) slogan
 created by Sun Microsystems to illustrate the cross-platform benets of
 the Java Virtual Machine.
 The difference is focused on the final performance since AlterNative outputs
 in native language and does not depend on any virtual machine.
\end_layout

\begin_layout Subsection
Assumptions
\end_layout

\begin_layout Standard
Some initial assumptions have made in AlterNative development:
\end_layout

\begin_layout Enumerate
The computational theory says that all the source code can be translated
 from one machine to another 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(REF)
\end_layout

\end_inset

, however, the code of an application can be divided in two parts:
\end_layout

\begin_deeper
\begin_layout Enumerate
Identical code in different operative systems (often with syntaxis differences
 but the syntactic sugar is the same).
 This occurs because the logical structures of the applications are the
 same in any machine or languaje and the different features of the operating
 system must be identical in different languages because they are targeting
 the same OS.
 AlterNative is trying to work with this kind of code.
 Moreover, most of the algorithms that can be optimized, can be classified
 inside this group of code.
\end_layout

\begin_layout Enumerate
Very difficult to translate code (i.e.
 graphical interfaces).
 There are several libraries that try to solve these problems (i.e.
 Qt or OpenGL for graphical interfaces).
\end_layout

\end_deeper
\begin_layout Enumerate
The code should be readable and easy editable by the developers, therefore,
 the translated code can be completed, or even improved (i.e.
 replace provided Garbage Collector with manual memory management).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Aqui faltarian unas "precondiciones" o assumptions que hacemos en AlterNative:
\end_layout

\begin_layout Plain Layout
1- Aunque la teoria de la computabilidad nos dice que todo el codigo es
 traducible de una maquina a otra (buscar referencias), si somos pragmaticos
 el codigo de un programa se divide en dos partes: 
\end_layout

\begin_layout Plain Layout
a) basicamente idéntico entre diferentes sistemas aunque haya diferencias
 de sintaxis.
 Esto tiene que ser asi porque las estructuras logicas de un programa son
 las mismas en cualquier lenguaje/maquina y ademas muchas funcionalidades
 del sistema operativo tienen que ser comunes a diferentes lenguajes ya
 que las usan del sistema operativo.
 Es mas, entre diferentes SOs muchas funcionalidades tienen que ser muy
 parecidas ya que por definicion han de ser compatibles, i.e red.
 Existe codigo que es diferente entre diferentes lenguajes al ser de diferente
 nivel pero basicamente en syntactic sugar que se utiliza para que el programado
r pueda expresar facilmente conceptos complejos que estan compuestos por
 elementos que ya existen en lenguajes de bajo nivel.
 
\end_layout

\begin_layout Plain Layout
b) codigo dificilmente traducible o que al ser traducido produce resultados
 muy diferentes, i.e GUI y graficos.
 Aunque existen librerias que intentan homogeneizar esto (QT, OpenGL, Swing.)
 En general o los resultados son diferentes en diferentes plataformas o
 se utiliza el minimo comun denominador de las posibilidades reales del
 sistema.
 
\end_layout

\begin_layout Plain Layout
La filosofia de AlterNative es atacar el codigo de tipo A (aunque mediante
 QT o OpenGL se podria intentar).
\end_layout

\begin_layout Plain Layout
Hay mucho codigo de tipo que tiene sentido en optimizar, p.e codigo algoritmo
\end_layout

\begin_layout Plain Layout
2-Otra asumption de AlterNative a diferencia de otros sistemas "parecidos"
 es que el codigo ha de ser entendible por un humano y facilmente modificable.
 De forma que el codigo traducido pueda ser completado, por ejemplo reemplazando
 el GC por gestion manual de la memoria.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Process
\end_layout

\begin_layout Subsection
Overall progress
\end_layout

\begin_layout Standard
The process of the AlterNative software is divided in three parts: Decompilation
, translation and recompilation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/Process.PNG
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AlterNative process
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
First of all the assembly received is passed through a decompiler in order
 to extract the source code.
 In this case the code extracted is C#.
 The code is not extracted in text format, but in an AST (Abstract Syntax
 Tree) that is an abstract representation with nodes and hierarchies of
 the code.
 This representation is organized in a tree from the top-level (Assembly)
 until de low-level (instructions, types and constants).
 The step of translation consists on apply different conversions to the
 AST in order to obtain a second AST representing the source code but in
 other language (in this case C++).
 The final step consists on compile the C++ code into a new assembly.
 This final assembly maintains the same funcionalities of the first assembly
 but takes benet of the native code performance.
 The effort of this software is not focused on the code translation, but
 it is focused in maintaining all the features and functionalities of the
 original code.
 The problem is that these features and functionalities often are directly
 related to the language, for instance a garbage collector, specic expressions
 or even language syntax.
 AlterNative is able to provide most of the features of the original code
 to the final code using external open-source libraries and propietary libraries
 in order to be fully compatible with high-level languages.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Subsubsection
Abstract Syntax Tree transformation
\end_layout

\begin_layout Standard
AlterNative is based on Abstract Syntax Tree (AST) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
revisar referencias
\end_layout

\end_inset

 transformations.
 As an example a method like 
\shape italic
void Run(string[] args)
\shape default
 can be represented with the AST shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AST-example"

\end_inset


\shape smallcaps
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/AlterNative_AST_REPORT_pag1.pdf
	width 100col%
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AST example 
\begin_inset CommandInset label
LatexCommand label
name "fig:AST-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Following the same concept, if the output language code wanted is C++, the
 method 
\shape italic
void Run(string[] args)
\shape default
 should be translated to 
\shape italic
void Run(string args[])
\shape default
.
 The AST needed to represent the C++ code is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AST-example-C++"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/AlterNative_AST_REPORT_pag2.pdf
	width 100col%
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
AST example C++ 
\begin_inset CommandInset label
LatexCommand label
name "fig:AST-example-C++"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this transformations AlterNative is able to translate the features
 of the input binary.
 In this section is explained an example of how a feature of a high level
 language is ported to a low level language.
 The language feature used is the 
\shape italic
foreach
\shape default
 keyword.
 The source code languages are C# for the input and C++ for the output.
\end_layout

\begin_layout Subsubsection
Practical example
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ForEach-example-input"

\end_inset

 shows the input source code.
 Actually the input is a compiled executable file containing the described
 code.
 The example used is a ver easy program that creates a float list and initialize
s some values to a random number.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "tabsize=4"
inline false
status open

\begin_layout Plain Layout

using System;
\end_layout

\begin_layout Plain Layout

using System.Collections.Generic;
\end_layout

\begin_layout Plain Layout

using System.Linq;
\end_layout

\begin_layout Plain Layout

using System.Text;
\end_layout

\begin_layout Plain Layout

using System.Collections.Generic;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

namespace ForEach {
\end_layout

\begin_layout Plain Layout

    class Program
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        static void Main(string[] args)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            List<float> myList = new List<float>();
\end_layout

\begin_layout Plain Layout

            myList.Add(5.6f);
\end_layout

\begin_layout Plain Layout

            myList.Add(523.6f);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            foreach (float f in myList)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                Console.WriteLine(f);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ForEach example input C#
\begin_inset CommandInset label
LatexCommand label
name "alg:ForEach-example-input"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting C++ code is listed in the algorithms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ForEach-example-C++"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ForEach-example-C++-1"

\end_inset

 (Header file and Code file respectively).
 Notice that the low level output code is completelly legible from the developer
 point of view instead of the traditional low level conventions and namings.
 AlterNative always tries to maintain a high level syntaxis in order to
 facilitate the developers work.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

#pragma once #include "System/System.h"
\end_layout

\begin_layout Plain Layout

#include "System/Collections/Generic/List.h"
\end_layout

\begin_layout Plain Layout

#include "System/Console.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace System::Collections::Generic;
\end_layout

\begin_layout Plain Layout

using namespace System; 
\end_layout

\begin_layout Plain Layout

namespace ForEach {
\end_layout

\begin_layout Plain Layout

	class Program : public virtual Object {
\end_layout

\begin_layout Plain Layout

		public:
\end_layout

\begin_layout Plain Layout

			static void Main(String* args[]);
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ForEach example C++ header output
\begin_inset CommandInset label
LatexCommand label
name "alg:ForEach-example-C++"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

#include "Program.h"
\end_layout

\begin_layout Plain Layout

namespace ForEach {
\end_layout

\begin_layout Plain Layout

	void Program::Main(String* args[]){
\end_layout

\begin_layout Plain Layout

		List_T<float>* myList = new List_T<float>();
\end_layout

\begin_layout Plain Layout

		myList->Add(5.6f);
\end_layout

\begin_layout Plain Layout

		myList->Add(523.6f);
\end_layout

\begin_layout Plain Layout

		FOREACH(_F, myList){
\end_layout

\begin_layout Plain Layout

			float f = *_F;
\end_layout

\begin_layout Plain Layout

			Console::WriteLine(f);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ForEach example C++ code implementation output
\begin_inset CommandInset label
LatexCommand label
name "alg:ForEach-example-C++-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the success of this example it is necessary the following external work:
\end_layout

\begin_layout Itemize

\series bold
External C++ library List_T<T>:
\series default
 A List library with the same syntaxis and class hierarchy of System.Collections.G
eneric.List<T> of .NET.
 In this case the List<T> .NET implementation extends from IEnumerable (an
 extended class of a classic iterator).
 In the C++ library this implementation has to follow the same hierarchy
 in order to take benefit of the IEnumerable and iterators methods, like
 the foreach feature.
 
\end_layout

\begin_layout Itemize

\series bold
External C++ library Console::WriteLine: 
\series default
A Console library with the same syntaxis and class hierarchy of System.Console.Wri
teLine(float f).
 This library is in charge of mapping this method to the C++ standard output
 (std::cout).
\end_layout

\begin_layout Itemize

\series bold
External macro for FOREACH: 
\series default
Supposing that the List_T<T> class declared is well templated and inherits
 from IEnumerable (also implemented in the library), the macro FOREACH call
 the methods that provide the iterators for managing the collection.
\end_layout

\begin_layout Section
Use cases
\end_layout

\begin_layout Standard
AlterNative can target to several use cases.
 In this section will be explained two of the more significative use cases:
 The performance improvement, and the cross-platform code generation tool.
\end_layout

\begin_layout Subsection
Performance
\end_layout

\begin_layout Standard
In general the major advantage of this platform can be obtained when an
 application or library is very complex in a computational way.
 The more complex is the target, the more the benefit can be obtained.
 Suppose the following scenario:
\end_layout

\begin_layout Standard
You have an application for Android written in Java.
 The Android system is composed by a Java application running over a DalvikVM
 (Java Virtual Machine) which is running over a unix distribution.
 This application takes several images from the camera and processes each
 frame in order to change from YUV format (Android standard) to RGB format.
 After trying your application in Java environment you obtain a framerate
 of 7 frames per second.
 After this test you want to upgrade your application improving the performance.
 AlterNative platform allows you to take the Java code layer in charge of
 processing the image and convert it to C++ code (and also provides you
 the code with JNI naming ready to use in Android or Java environments)
 which allows you to run code below the DalvikVM.
 After that you repeat the test but with the processing layer running in
 C++ and you obtain 14 frames per second (two times faster than the first
 one).
 The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Java-vs-C++"

\end_inset

 shows real screenshots of the explained example.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/JavaProc.png
	lyxscale 40
	width 25text%
	height 17text%

\end_inset


\begin_inset Graphics
	filename Figures/nativeProc.png
	lyxscale 40
	width 25text%
	height 17text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Java vs C++ performance.
 Device: Samsumg Galaxy S III Running Android 4.0 
\begin_inset CommandInset label
LatexCommand label
name "fig:Java-vs-C++"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cross-Platform embedded systems
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
EJEMPLO GERARD
\end_layout

\end_inset


\end_layout

\begin_layout Section
Tests results
\end_layout

\begin_layout Subsection
Tests suite
\end_layout

\begin_layout Standard
AlterNative project is provided by a testing suite following the model of
 regression test.
 Every test is in charge of check if a specific language feature is translated
 and compiled in the correct way.
 The test outputs information about the AlterNative process, the cross-compilati
on process, the compilation in the target platform process, the time performance
 difference between the original code and the translated code, the line
 differences between the original and the translated code and the comparison
 of the original and final program outputs.
\end_layout

\begin_layout Standard
For the evaluation of the system a CPU stress performance test will be executed.
 The tests selected are the fannkuch-redux benchmark 
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"

\end_inset

 and the n-bodies benchmark 
\begin_inset CommandInset citation
LatexCommand cite
key "key-6"

\end_inset

.
 The source codes used are listed below.
\end_layout

\begin_layout Subsection
Fannkuch-redux benchmark
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using System;
\end_layout

\begin_layout Plain Layout

class FannkuchRedux 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   public static int[] fannkuch(int n) {
\end_layout

\begin_layout Plain Layout

      int[] p = new int[n], q = new int[n], s = new int[n];
\end_layout

\begin_layout Plain Layout

       int sign = 1, maxflips = 0, sum = 0, m = n-1;
\end_layout

\begin_layout Plain Layout

      for(int i=0; i<n; i++){ p[i] = i; q[i] = i; s[i] = i; }
\end_layout

\begin_layout Plain Layout

            do {
\end_layout

\begin_layout Plain Layout

         // Copy and flip.
\end_layout

\begin_layout Plain Layout

         var q0 = p[0];// Cache 0th element.
\end_layout

\begin_layout Plain Layout

         if (q0 != 0){
\end_layout

\begin_layout Plain Layout

            for(int i=1; i<n; i++) q[i] = p[i];// Work on a copy.
\end_layout

\begin_layout Plain Layout

            var flips = 1;
\end_layout

\begin_layout Plain Layout

            do {
\end_layout

\begin_layout Plain Layout

                var qq = q[q0]; 
\end_layout

\begin_layout Plain Layout

               if (qq == 0){// ...
 until 0th element is 0.
\end_layout

\begin_layout Plain Layout

                  sum += sign*flips;
\end_layout

\begin_layout Plain Layout

	          if (flips > maxflips) maxflips = flips;// New maximum?
\end_layout

\begin_layout Plain Layout

                  break;
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

  	       q[q0] = q0;
\end_layout

\begin_layout Plain Layout

 	       if (q0 >= 3){
\end_layout

\begin_layout Plain Layout

	          int i = 1, j = q0 - 1, t;
\end_layout

\begin_layout Plain Layout

                  do { t = q[i]; q[i] = q[j]; q[j] = t; i++; j--; } while
 (i < j);
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

	       q0 = qq; flips++;
\end_layout

\begin_layout Plain Layout

            } while (true);
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

         // Permute.
\end_layout

\begin_layout Plain Layout

         if (sign == 1){
\end_layout

\begin_layout Plain Layout

			// Rotate 0<-1.
\end_layout

\begin_layout Plain Layout

            var t = p[1]; p[1] = p[0]; p[0] = t; sign = -1;
\end_layout

\begin_layout Plain Layout

         } else {
\end_layout

\begin_layout Plain Layout

			// Rotate 0<-1 and 0<-1<-2.
\end_layout

\begin_layout Plain Layout

            var t = p[1]; p[1] = p[2]; p[2] = t; sign = 1;  
\end_layout

\begin_layout Plain Layout

            for(int i=2; i<n; i++){
\end_layout

\begin_layout Plain Layout

 	       var sx = s[i];
\end_layout

\begin_layout Plain Layout

	       if (sx != 0){ s[i] = sx-1; break; }
\end_layout

\begin_layout Plain Layout

	       if (i == m) return new int[]{sum,maxflips};  // Out of permutations.
\end_layout

\begin_layout Plain Layout

	       s[i] = i;
\end_layout

\begin_layout Plain Layout

	       // Rotate 0<-...<-i+1.
\end_layout

\begin_layout Plain Layout

	       t = p[0]; for(int j=0; j<=i; j++){ p[j] = p[j+1]; } p[i+1] = t;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

         }
\end_layout

\begin_layout Plain Layout

      } while (true);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   static void Main(string[] args){
\end_layout

\begin_layout Plain Layout

      int n = (args.Length > 0) ? Int32.Parse(args[0]) : 7;
\end_layout

\begin_layout Plain Layout

      var pf = fannkuch(n);
\end_layout

\begin_layout Plain Layout

      Console.Write("{0}
\backslash
nPfannkuchen({1}) = {2}
\backslash
n", pf[0], n, pf[1]);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fannkuch-redux test C# code
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have compared three languages with three compilation targets.
 The languages are C# (original), C++ original (manually translated) and
 C++ alternative (obtained automatically).
 The three compilation targets are Windows 32 bits, Linux and Android, all
 of them with Release optimizations.
 The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Time-in-function-1"

\end_inset

 shows the comparison of the languages in Linux and Android targets.
 In the Windows platform, C# .NET performs several optimizations that allows
 the executable to run with a reasonable performance.
 Even sometimes these optimizations makes the executable overcome to the
 C++ exectuable version.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/pegado2.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Time in function of the target platform for the Fannkuch-redux test
\begin_inset CommandInset label
LatexCommand label
name "fig:Time-in-function-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The C++ original code obtains the better benchmark as expected.
 The AlterNative C++ generated code is near the original code.
 This behaviour is also expected because AlterNative does not implement
 stack or heap optimizations in the variables, now all the variables are
 allocated dynamically.
 The access to these variables are computationally expensive than in stack
 variables.
\end_layout

\begin_layout Subsection
N-Bodies benchmark
\end_layout

\begin_layout Standard
The platforms and languages tested in this benchmark are the same that the
 tested in the Fannkuch-redux benchmark 
\begin_inset CommandInset citation
LatexCommand cite
key "key-6"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\tiny},language={[GNU]C++}"
inline false
status open

\begin_layout Plain Layout

using System;
\end_layout

\begin_layout Plain Layout

class NBody {
\end_layout

\begin_layout Plain Layout

	public static void Main(String[] args) {
\end_layout

\begin_layout Plain Layout

		int n = 50000000;
\end_layout

\begin_layout Plain Layout

		NBodySystem bodies = new NBodySystem();
\end_layout

\begin_layout Plain Layout

		Console.WriteLine("{0:f9}",bodies.Energy());
\end_layout

\begin_layout Plain Layout

		for (int i=0; i<n; i++)
\end_layout

\begin_layout Plain Layout

			bodies.Advance(0.01);
\end_layout

\begin_layout Plain Layout

		Console.WriteLine("{0:f9}",bodies.Energy());
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class NBodySystem {
\end_layout

\begin_layout Plain Layout

	private Body[] bodies;
\end_layout

\begin_layout Plain Layout

	public NBodySystem() {
\end_layout

\begin_layout Plain Layout

		bodies = new Body[]{
\end_layout

\begin_layout Plain Layout

			Body.Sun(),
\end_layout

\begin_layout Plain Layout

			Body.Jupiter(),
\end_layout

\begin_layout Plain Layout

			Body.Saturn(),
\end_layout

\begin_layout Plain Layout

			Body.Uranus(),
\end_layout

\begin_layout Plain Layout

			Body.Neptune()
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

		double px = 0.0;
\end_layout

\begin_layout Plain Layout

		double py = 0.0;
\end_layout

\begin_layout Plain Layout

		double pz = 0.0;		
\end_layout

\begin_layout Plain Layout

		foreach (Body body in bodies) {
\end_layout

\begin_layout Plain Layout

			px += body.vx * body.mass;
\end_layout

\begin_layout Plain Layout

			py += body.vy * body.mass;
\end_layout

\begin_layout Plain Layout

			pz += body.vz * body.mass;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		bodies[0].OffsetMomentum(px,py,pz);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public void Advance(double dt) {
\end_layout

\begin_layout Plain Layout

		double dx, dy, dz, distance, mag;	 
\end_layout

\begin_layout Plain Layout

		for (int i=0; i < bodies.Length; i++) {
\end_layout

\begin_layout Plain Layout

			for (int j=i+1; j < bodies.Length; j++) {
\end_layout

\begin_layout Plain Layout

				dx = bodies[i].x - bodies[j].x;
\end_layout

\begin_layout Plain Layout

				dy = bodies[i].y - bodies[j].y;
\end_layout

\begin_layout Plain Layout

				dz = bodies[i].z - bodies[j].z;				
\end_layout

\begin_layout Plain Layout

				distance = Math.Sqrt(dx*dx + dy*dy + dz*dz);
\end_layout

\begin_layout Plain Layout

				mag = dt / (distance * distance * distance); 			
\end_layout

\begin_layout Plain Layout

				bodies[i].vx -= dx * bodies[j].mass * mag;
\end_layout

\begin_layout Plain Layout

				bodies[i].vy -= dy * bodies[j].mass * mag;
\end_layout

\begin_layout Plain Layout

				bodies[i].vz -= dz * bodies[j].mass * mag;				
\end_layout

\begin_layout Plain Layout

				bodies[j].vx += dx * bodies[i].mass * mag;
\end_layout

\begin_layout Plain Layout

				bodies[j].vy += dy * bodies[i].mass * mag;
\end_layout

\begin_layout Plain Layout

				bodies[j].vz += dz * bodies[i].mass * mag;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}	
\end_layout

\begin_layout Plain Layout

		foreach (Body body in bodies) {
\end_layout

\begin_layout Plain Layout

			body.x += dt * body.vx;
\end_layout

\begin_layout Plain Layout

			body.y += dt * body.vy;
\end_layout

\begin_layout Plain Layout

			body.z += dt * body.vz;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}	
\end_layout

\begin_layout Plain Layout

	public double Energy() {
\end_layout

\begin_layout Plain Layout

		double dx, dy, dz, distance;
\end_layout

\begin_layout Plain Layout

		double e = 0.0;		
\end_layout

\begin_layout Plain Layout

		for (int i=0; i < bodies.Length; i++) {
\end_layout

\begin_layout Plain Layout

			e += 0.5 * bodies[i].mass *( bodies[i].vx * bodies[i].vx
\end_layout

\begin_layout Plain Layout

			+ bodies[i].vy * bodies[i].vy
\end_layout

\begin_layout Plain Layout

			+ bodies[i].vz * bodies[i].vz );			
\end_layout

\begin_layout Plain Layout

			for (int j=i+1; j < bodies.Length; j++) {
\end_layout

\begin_layout Plain Layout

				dx = bodies[i].x - bodies[j].x;
\end_layout

\begin_layout Plain Layout

				dy = bodies[i].y - bodies[j].y;
\end_layout

\begin_layout Plain Layout

				dz = bodies[i].z - bodies[j].z;				
\end_layout

\begin_layout Plain Layout

				distance = Math.Sqrt(dx*dx + dy*dy + dz*dz);
\end_layout

\begin_layout Plain Layout

				e -= (bodies[i].mass * bodies[j].mass) / distance;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		return e;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Body {
\end_layout

\begin_layout Plain Layout

	const double PI = 3.141592653589793;
\end_layout

\begin_layout Plain Layout

	const double SOLAR_MASS = 4 * PI * PI;
\end_layout

\begin_layout Plain Layout

	const double DAYS_PER_YEAR = 365.24;	
\end_layout

\begin_layout Plain Layout

	public double x, y, z, vx, vy, vz, mass;	
\end_layout

\begin_layout Plain Layout

	public Body(){}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	internal static Body Jupiter() {
\end_layout

\begin_layout Plain Layout

		Body p = new Body();
\end_layout

\begin_layout Plain Layout

		p.x = 4.84143144246472090e+00;	p.y = -1.16032004402742839e+00;
\end_layout

\begin_layout Plain Layout

		p.z = -1.03622044471123109e-01;
\end_layout

\begin_layout Plain Layout

		p.vx = 1.66007664274403694e-03 * DAYS_PER_YEAR;
\end_layout

\begin_layout Plain Layout

		p.vy = 7.69901118419740425e-03 * DAYS_PER_YEAR;
\end_layout

\begin_layout Plain Layout

		p.vz = -6.90460016972063023e-05 * DAYS_PER_YEAR;
\end_layout

\begin_layout Plain Layout

		p.mass = 9.54791938424326609e-04 * SOLAR_MASS;
\end_layout

\begin_layout Plain Layout

		return p;
\end_layout

\begin_layout Plain Layout

	}	
\end_layout

\begin_layout Plain Layout

	internal static Body Saturn() {
\end_layout

\begin_layout Plain Layout

		//INITIALIZATION CODE ...
\end_layout

\begin_layout Plain Layout

		return p;    
\end_layout

\begin_layout Plain Layout

	}	 
\end_layout

\begin_layout Plain Layout

	internal static Body Uranus() {
\end_layout

\begin_layout Plain Layout

		//INITIALIZATION CODE ...
\end_layout

\begin_layout Plain Layout

		return p;
\end_layout

\begin_layout Plain Layout

	}	
\end_layout

\begin_layout Plain Layout

	internal static Body Neptune() {
\end_layout

\begin_layout Plain Layout

		//INITIALIZATION CODE ...
\end_layout

\begin_layout Plain Layout

		return p;    
\end_layout

\begin_layout Plain Layout

	}	
\end_layout

\begin_layout Plain Layout

	internal static Body Sun() {
\end_layout

\begin_layout Plain Layout

		//INITIALIZATION CODE ...
\end_layout

\begin_layout Plain Layout

		return p;
\end_layout

\begin_layout Plain Layout

	}	
\end_layout

\begin_layout Plain Layout

	internal Body OffsetMomentum(double px, double py, double pz) {
\end_layout

\begin_layout Plain Layout

		vx = -px / SOLAR_MASS;	vy = -py / SOLAR_MASS;
\end_layout

\begin_layout Plain Layout

		vz = -pz / SOLAR_MASS;
\end_layout

\begin_layout Plain Layout

		return this;
\end_layout

\begin_layout Plain Layout

	}			
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
N-Bodies algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results of the execution of this test are illustrated in the figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Time-in-function-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/pegado4.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Time in function of the target platform for the N-Body test
\begin_inset CommandInset label
LatexCommand label
name "fig:Time-in-function"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The behaviour of this test is similar to the Fannkuch-redux benchmark test.
 The difference between the original C++ code and the AlterNative C++ code
 in this case is more accused than in the previous case.
 This result is due to this example access the memory a huge number of times.
 In stacked objects this is much faster than in dynamically allocated objects.
\end_layout

\begin_layout Subsection
Cross-platform embedded systems
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Resultados gerard
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
Most of the cross-platform tools in the community are focused only on fast
 development for different devices (for instance games for smartphones).
 AlterNative a part of maintaining the objective of facilitate the easy
 and fast development, also is focused on the final performance of the applicati
on.
 Multiplatform systems based on virtual machines, or in HTML + CSS frameworks
 are useful for visual applications which do not require a high computational
 power, the main advantage of AlterNative software is that it is able to
 run code with native performance while the user is programming its code
 without taking into account the final application performance.
\end_layout

\begin_layout Standard
AlterNative platform also allows cross-platform development adapted to computers
, mobiles and also embedded systems.
 This work is a novel tool that allows the developers to save time and develop
 powerful and cross-platform applications able to run in the major part
 of the devices 
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
The results obtained in this work are good in a cpu performance point of
 view.
 However, other important point in the high-level languages is the memory
 management.
 The memory management of high-level languages often depends in an external
 service called garbage collector.
 AlterNative implements a garbage collector in C++ using the popular Boehm
 gc library 
\begin_inset CommandInset citation
LatexCommand cite
key "key-32"

\end_inset

.
 This implementation consists on track all the new objects and all the 
\begin_inset Quotes eld
\end_inset

destroyed
\begin_inset Quotes erd
\end_inset

 objects in order to manage all the memory allocations of the program.
 One future research line for this work is to automatize the garbage collection
 process in order to deallocate unused memory in the program.
 In the actual implementation, the system is prepared but never deallocates
 unused memory.
 A Binary Tree test 
\begin_inset CommandInset citation
LatexCommand cite
key "key-29"

\end_inset

 has been made in order to check that the memory management is not working
 properly.
 The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Memory-allocation-in"

\end_inset

 shows the results.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/pegado3.emf
	lyxscale 30
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Memory allocation in Binary-tree test
\begin_inset CommandInset label
LatexCommand label
name "fig:Memory-allocation-in"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other future line in the project is to complete and expand the actual support
 library in order to cover all the basic C# language features.
\end_layout

\begin_layout Standard
Regarding the testing suite, there are several techniques for optimizing
 and reducing the cost of the regression test.
 An example of these optimizations can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "key-33,key-34,key-35"

\end_inset

.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

ILSpy homepage, http://ilspy.net/, May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-12"

\end_inset

A.
 V.
 Aho, R.
 Sethi, J.
 D.
 Ullman, 
\begin_inset Quotes eld
\end_inset

Compilers.
 Principles, Techniques, and Tools
\begin_inset Quotes erd
\end_inset

, Bell Telephone Laboratories, United States of America, 1986
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset

D.
 Grune, H.
 E.
 Bal, C.
 J.H.
 Jacobs, K.
 G.
 Langendoen 
\begin_inset Quotes eld
\end_inset

Modern Compiler Design
\begin_inset Quotes erd
\end_inset

, Vrije Universiteit, Amsterdam and Delf University, John Wiley & Sons,
 Ltd, England, 2000
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-13"

\end_inset

M.
 Palmieri, I.
 Singh, A.
 Cicchetti, 
\begin_inset Quotes eld
\end_inset

Comparison of Cross-Platform Mobile Development Tools
\begin_inset Quotes erd
\end_inset

, Innovation, Design and Engineering Mälardalen University, Sweden, 2012
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-19"

\end_inset

B.
 Curtis.
 PhoneGap and the Enterprice.
 http://www.slideshare.net/drbac/phonegap-day-ibm-phonegap-andthe- enterprise,
 July 2011
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-24"

\end_inset

Motorola Solutions.
 http://www.motorola.com/Business/USEN/ Business+Product+and+Services/Software+and
+Applications/RhoMobile+Suite, 2012
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-20"

\end_inset

Leckylao.
 Rhodes framework: Agile mobile web development.
 http://leckylao.com/2010/06/12/rhodes-framework-agile-mobileweb- development,
 June 2010
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-21"

\end_inset

DragonRad.
 http://dragonrad.com, 2012
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-22"

\end_inset

M.
 Kindborg.
 The wormhole javascript library.
 http://www.mosync.com/content/html5-javascript-wormhole, February 2012
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-14"

\end_inset

Particlecode, 
\begin_inset Quotes eld
\end_inset

Overview | Particle Code
\begin_inset Quotes erd
\end_inset

, http://www.particlecode.com/features/overview/, May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-26"

\end_inset

Netduino mini specificatinos, http://www.netduino.com/netduinomini/specs.htm,
 May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-27"

\end_inset

Xamarin, 
\begin_inset Quotes eld
\end_inset

Mono, a technical whitepaper
\begin_inset Quotes erd
\end_inset

 http://www.mono-project.com/Mono,_a_technical_whitepaper May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Benchmarks game, 
\begin_inset Quotes eld
\end_inset

fannkuch-redux
\begin_inset Quotes erd
\end_inset

, http://shootout.alioth.debian.org/u32/
\begin_inset Newline linebreak
\end_inset

performance.php?test=fannkuchredux, May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset

Benchmarks game, 
\begin_inset Quotes eld
\end_inset

nbody
\begin_inset Quotes erd
\end_inset

, http://benchmarksgame.alioth.debian.org/u32q/
\begin_inset Newline linebreak
\end_inset

program.php?test=nbody, May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-32"

\end_inset

HPLabs, 
\begin_inset Quotes eld
\end_inset

A garbage collector for C and C++
\begin_inset Quotes erd
\end_inset

, http://www.hpl.hp.com/personal/Hans_Boehm/gc/, May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-29"

\end_inset

Benchmarks game, 
\begin_inset Quotes eld
\end_inset

Binary trees
\begin_inset Quotes erd
\end_inset

, http://benchmarksgame.alioth.debian.org/u32/
\begin_inset Newline linebreak
\end_inset

benchmark.php?test=binarytrees, May 2013
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-33"

\end_inset

P.
 Nagahawatte and H.
 Do, 
\begin_inset Quotes eld
\end_inset

The Effectiveness of Tegression Testing Techniques in Reducing the Occurrence
 of Residual Defects
\begin_inset Quotes erd
\end_inset

, Department of Computer Science, North Dakota State University, Fargo,
 2010
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-34"

\end_inset

Q.
 Gu, B.Tang, D.
 Chen, 
\begin_inset Quotes eld
\end_inset

Optimal Regression Testing based on Selective Coverage of Test Requirements
\begin_inset Quotes erd
\end_inset

, Nanjing University, University of Aizu, 2010
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-35"

\end_inset

A.
 Kumar, S.
 Tiwari, K.
 K.
 Mishra and A.K.
 Misra, 
\begin_inset Quotes eld
\end_inset

Generation of Efficient Test Data using Path Selection Strategy with Elitist
 GA in Regression Testing
\begin_inset Quotes erd
\end_inset

, Computer Science & Engineering Department, MNNIT, allahabad INDIA, 2010
\end_layout

\end_body
\end_document
