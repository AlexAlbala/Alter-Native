using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using ICSharpCode.NRefactory.VB.Ast;
using ICSharpCode.NRefactory.VB.Parser;
using ASTAttribute = ICSharpCode.NRefactory.VB.Ast.Attribute;
using Roles = ICSharpCode.NRefactory.VB.AstNode.Roles;

COMPILER VB

#region AUTOGENERATED TOKENS SECTION
TOKENS
	/* ----- terminal classes ----- */
	/* EOF is 0 */
	EOL
	ident
	LiteralString
	LiteralCharacter
	LiteralInteger
	LiteralDouble
	LiteralSingle
	LiteralDecimal
	LiteralDate
	XmlOpenTag					// <
	XmlCloseTag				// >
	XmlStartInlineVB			// <%=
	XmlEndInlineVB				// %>
	XmlCloseTagEmptyElement	// />
	XmlOpenEndTag				// </
	XmlContent					// ...
	XmlComment					// <!-- ... -->
	XmlCData					// <![CDATA[...]]>
	XmlProcessingInstruction	

	/* ----- special character ----- */
	"="
	":"
	","
	"&"
	"/"
	"\\"
	"."
	"..."
	".@"
	"!"
	"-"
	"+"
	"^"
	"?"
	"*"
	"{"
	"}"
	"("
	")"
	">"
	"<"
	"<>"
	">="
	"<="
	"<<"
	">>"
	"+="
	"^="
	"-="
	"*="
	"/="
	"\\="
	"<<="
	">>="
	"&="
	":="

	/* ----- keywords ----- */
	"AddHandler"
	"AddressOf"
	"Aggregate"
	"Alias"
	"And"
	"AndAlso"
	"Ansi"
	"As"
	"Ascending"
	"Assembly"
	"Auto"
	"Binary"
	"Boolean"
	"ByRef"
	"By"
	"Byte"
	"ByVal"
	"Call"
	"Case"
	"Catch"
	"CBool"
	"CByte"
	"CChar"
	"CDate"
	"CDbl"
	"CDec"
	"Char"
	"CInt"
	"Class"
	"CLng"
	"CObj"
	"Compare"
	"Const"
	"Continue"
	"CSByte"
	"CShort"
	"CSng"
	"CStr"
	"CType"
	"CUInt"
	"CULng"
	"CUShort"
	"Custom"
	"Date"
	"Decimal"
	"Declare"
	"Default"
	"Delegate"
	"Descending"
	"Dim"
	"DirectCast"
	"Distinct"
	"Do"
	"Double"
	"Each"
	"Else"
	"ElseIf"
	"End"
	"EndIf"
	"Enum"
	"Equals"
	"Erase"
	"Error"
	"Event"
	"Exit"
	"Explicit"
	"False"
	"Finally"
	"For"
	"Friend"
	"From"
	"Function"
	"Get"
	"GetType"
	"Global"
	"GoSub"
	"GoTo"
	"Group"
	"Handles"
	"If"
	"Implements"
	"Imports"
	"In"
	"Infer"
	"Inherits"
	"Integer"
	"Interface"
	"Into"
	"Is"
	"IsNot"
	"Join"
	"Key"
	"Let"
	"Lib"
	"Like"
	"Long"
	"Loop"
	"Me"
	"Mod"
	"Module"
	"MustInherit"
	"MustOverride"
	"MyBase"
	"MyClass"
	"Namespace"
	"Narrowing"
	"New"
	"Next"
	"Not"
	"Nothing"
	"NotInheritable"
	"NotOverridable"
	"Object"
	"Of"
	"Off"
	"On"
	"Operator"
	"Option"
	"Optional"
	"Or"
	"Order"
	"OrElse"
	"Out"
	"Overloads"
	"Overridable"
	"Overrides"
	"ParamArray"
	"Partial"
	"Preserve"
	"Private"
	"Property"
	"Protected"
	"Public"
	"RaiseEvent"
	"ReadOnly"
	"ReDim"
	"Rem"
	"RemoveHandler"
	"Resume"
	"Return"
	"SByte"
	"Select"
	"Set"
	"Shadows"
	"Shared"
	"Short"
	"Single"
	"Skip"
	"Static"
	"Step"
	"Stop"
	"Strict"
	"String"
	"Structure"
	"Sub"
	"SyncLock"
	"Take"
	"Text"
	"Then"
	"Throw"
	"To"
	"True"
	"Try"
	"TryCast"
	"TypeOf"
	"UInteger"
	"ULong"
	"Unicode"
	"Until"
	"UShort"
	"Using"
	"Variant"
	"Wend"
	"When"
	"Where"
	"While"
	"Widening"
	"With"
	"WithEvents"
	"WriteOnly"
	"Xor"
	"GetXmlNamespace"
#endregion

PRODUCTIONS

#region General

VB =
(.
	compilationUnit = new CompilationUnit();
	NodeStart(compilationUnit);
	Get();
.)
	{ StatementTerminator }
	{ OptionStatement<CompilationUnit.MemberRole> { StatementTerminator } }
	{ ImportsStatement<CompilationUnit.MemberRole> { StatementTerminator } }
/*	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection { StatementTerminator } }
	{ NamespaceMemberDecl { StatementTerminator } } */
.

StatementTerminator = SYNC ( EOL<Roles.StatementTerminator> | ":"<Roles.StatementTerminator> ) .

#region Identifier

//IdentifierOrKeyword<out string identifier> = ANY (. identifier = t.val; .) .

// This production handles pseudo keywords that are needed in the grammar
Identifier	=
	IdentifierForFieldDeclaration
	| "Custom"
.

IdentifierForFieldDeclaration =
	ident
	| "Aggregate"
	| "Ansi"
	| "Ascending"
	| "Assembly"
	| "Auto"
	| "Binary"
	| "By"
	| "Compare"
	| "Descending"
	| "Distinct"
	| "Equals"
	| "Explicit"
	| "From"
	| "Group"
	| "Infer"
	| "Into"
	| "Join"
	| "Key"
	| "Off"
	| "Order"
	| "Out"
	| "Preserve"
	| "Skip"
	| "Take"
	| "Text"
	| "Unicode"
	| "Until"
	| "Where"
.
#endregion

TypeName<out AstType type> (. type = null; .) =
	PrimitiveTypeName<out type> |
	QualifiedTypeName<out type>
.
QualifiedTypeName<out AstType type> =
	( "Global" | Identifier ) (. type = new SimpleType(t.val, t.Location); .)
	{ "." Identifier (. type = new QualifiedType(type, new Identifier(t.val, t.Location)); .) }
	// TODO : add TypeArguments
.

PrimitiveTypeName<out AstType type> (. type = null; .) =
	"Object"		(. type = new PrimitiveType("Object", t.Location); .)
	| "Boolean"	(. type = new PrimitiveType("Boolean", t.Location); .)
	| "Date"		(. type = new PrimitiveType("Date", t.Location); .)
	| "Char"		(. type = new PrimitiveType("Char", t.Location); .)
	| "String"		(. type = new PrimitiveType("String", t.Location); .)
	| "Decimal"	(. type = new PrimitiveType("Decimal", t.Location); .)
	| "Byte"		(. type = new PrimitiveType("Byte", t.Location); .)
	| "Short"		(. type = new PrimitiveType("Short", t.Location); .)
	| "Integer"	(. type = new PrimitiveType("Integer", t.Location); .)
	| "Long"		(. type = new PrimitiveType("Long", t.Location); .)
	| "Single"		(. type = new PrimitiveType("Single", t.Location); .)
	| "Double"		(. type = new PrimitiveType("Double", t.Location); .)
	| "UInteger"	(. type = new PrimitiveType("UInteger", t.Location); .)
	| "ULong"		(. type = new PrimitiveType("ULong", t.Location); .)
	| "UShort"		(. type = new PrimitiveType("UShort", t.Location); .)
	| "SByte"		(. type = new PrimitiveType("SByte", t.Location); .)
.

/*
ParameterModifier<ParamModifierList m> =
	"ByVal"			(. m.Add(ParameterModifiers.In); .)
	| "ByRef"			(. m.Add(ParameterModifiers.Ref); .)
	| "Optional"		(. m.Add(ParameterModifiers.Optional); .)
	| "ParamArray"	(. m.Add(ParameterModifiers.Params); .)
.

TypeModifier<ModifierList m> =
	  "Public"				(. m.Add(Modifiers.Public, t.Location); .)
	| "Protected"			(. m.Add(Modifiers.Protected, t.Location); .)
	| "Friend"				(. m.Add(Modifiers.Internal, t.Location); .)
	| "Private"			(. m.Add(Modifiers.Private, t.Location); .)
	| "Shared"				(. m.Add(Modifiers.Static, t.Location); .)
	| "Shadows"			(. m.Add(Modifiers.New, t.Location); .)
	| "MustInherit"		(. m.Add(Modifiers.Abstract, t.Location); .)
	| "NotInheritable"	(. m.Add(Modifiers.Sealed, t.Location); .)
	| "Partial"			(. m.Add(Modifiers.Partial, t.Location); .)
.

MemberModifier<ModifierList m> =
	  "MustInherit"		(.m.Add(Modifiers.Abstract, t.Location);.)
	| "Default"			(.m.Add(Modifiers.Default, t.Location);.)
	| "Friend"			(.m.Add(Modifiers.Internal, t.Location);.)
	| "Shadows"			(.m.Add(Modifiers.New, t.Location);.)
	| "Overrides"		(.m.Add(Modifiers.Override, t.Location);.)
	| "MustOverride"	(.m.Add(Modifiers.Abstract, t.Location);.)
	| "Private"			(.m.Add(Modifiers.Private, t.Location);.)
	| "Protected"		(.m.Add(Modifiers.Protected, t.Location);.)
	| "Public"			(.m.Add(Modifiers.Public, t.Location);.)
	| "NotInheritable"	(.m.Add(Modifiers.Sealed, t.Location);.)
	| "NotOverridable"	(.m.Add(Modifiers.Sealed, t.Location);.)
	| "Shared"			(.m.Add(Modifiers.Static, t.Location);.)
	| "Overridable"		(.m.Add(Modifiers.Virtual, t.Location);.)
	| "Overloads"		(.m.Add(Modifiers.Overloads, t.Location);.)
	| "ReadOnly"		(.m.Add(Modifiers.ReadOnly, t.Location);.)
	| "WriteOnly"		(.m.Add(Modifiers.WriteOnly, t.Location);.)
	| "WithEvents"		(.m.Add(Modifiers.WithEvents, t.Location);.)
	| "Dim"				(.m.Add(Modifiers.Dim, t.Location);.)
	| "Partial"			(.m.Add(Modifiers.Partial, t.Location);.)
.

PropertyAccessorAccessModifier<out Modifiers m> =
	(. m = Modifiers.None; .)
	{
		"Public"    (. m |= Modifiers.Public; .)
	 |  "Protected" (. m |= Modifiers.Protected; .)
	 |  "Friend"    (. m |= Modifiers.Internal; .)
	 |  "Private"   (. m |= Modifiers.Private; .)
	}
.
*/
#endregion

#region Global

#region OptionStatement

OptionStatement<auto> =
	"Option"<Roles.Keyword> (
		"Explicit"<Ast.OptionStatement.OptionTypeRole> (. result.OptionType = OptionType.Explicit; .) [ OnOff<result> ]
		| "Strict"<Ast.OptionStatement.OptionTypeRole> (. result.OptionType = OptionType.Strict; .) [ OnOff<result> ]
		| "Infer"<Ast.OptionStatement.OptionTypeRole> (. result.OptionType = OptionType.Infer; .) [ OnOff<result> ]
		| "Compare"<Ast.OptionStatement.OptionTypeRole> (. result.OptionType = OptionType.Compare; .) BinaryText<result>
	) StatementTerminator
.

OnOff<OptionStatement os> =
	"On"<Ast.OptionStatement.OptionValueRole> (. os.OptionValue = OptionValue.On; .)
	| "Off"<Ast.OptionStatement.OptionValueRole> (. os.OptionValue  = OptionValue.Off; .)
.

BinaryText<OptionStatement os> =
	"Text"<Ast.OptionStatement.OptionValueRole> (. os.OptionValue = OptionValue.Text; .)
	| "Binary"<Ast.OptionStatement.OptionValueRole> (. os.OptionValue  = OptionValue.Binary; .)
.

#endregion

#region ImportsStatement

ImportsStatement<auto> =
	"Imports"<Roles.Keyword> ImportsClause { "," ImportsClause } StatementTerminator
.

ImportsClause =
	( IF (IsAliasImportsClause())
		AliasImportsClause<Ast.ImportsStatement.ImportsClauseRole> |
	MemberImportsClause<Ast.ImportsStatement.ImportsClauseRole> |
	XmlNamespaceImportsClause<Ast.ImportsStatement.ImportsClauseRole> ) SYNC .

AliasImportsClause<auto> (. AstType alias; .) =
	// Type characters are not allowed in identifiers here
	Identifier (. result.Name = new Identifier(t.val, t.Location); .) "=" TypeName<out alias> (. result.Alias = alias; .)
.

MemberImportsClause<auto> (. AstType member; .) =
	TypeName<out member> (. result.Member = member; .)
.

XmlNamespaceImportsClause<auto> =
	XmlOpenTag<Roles.XmlOpenTag> Identifier/*<Roles.XmlIdentifier>*/ "="<Roles.Assign> LiteralString/*<Roles.XmlLiteralString>*/ XmlCloseTag<Roles.XmlCloseTag>
.

#endregion

#endregion

END VB .
